# Manual page zsh(1)
#
# Commands are first read from /etc/zsh/zshenv; Commands are then read from $ZDOTDIR/.zshenv
# If the shell is a login shell, commands are read from /etc/zsh/zprofile and then $ZDOTDIR/.zprofile
# Then, if the shell is interactive, commands are read from /etc/zsh/zshrc and then $ZDOTDIR/.zshrc
# Finally, if the shell is a login shell, /etc/zsh/zlogin and $ZDOTDIR/.zlogin are read.
# If ZDOTDIR is unset, HOME is used instead.

# Load the zinit-module which transparently and automatically compiles sourced scripts.
# 还可以对每个脚本计时
# See https://github.com/zdharma-continuum/zinit-module
# module_path+=("$ZDOTDIR/zinit/module/Src")
module_path+=("$HOME/.zinit/mod-bin/Src")
zmodload zdharma_continuum/zinit
# TODO 将 starship 也作为一个 module
# https://github.com/mgattozzi/zsh-module-poc

# 注意：如果 `terminal.integrated.shellIntegration.enabled` 被启用，
# vscode 会在第一个 prompt 加载前将 ZDOTDIR 设为 /tmp/vscode-zsh
# **** 注意这里没有 export，因此在 zsh 中嵌套启动 zsh 时，仍然会 source ~/.zshrc ！****
ZDOTDIR=$XDG_CONFIG_HOME/zsh

# use_p10k() {
#     # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.config/zsh/.zshrc.
#     # Initialization code that may require console input (password prompts, [y/n]
#     # confirmations, etc.) must go above this block; everything else may go below.
#     if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
#         . "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
#     fi

#     . /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme
#     # To customize prompt, run `p10k configure` or edit ~/.config/zsh/.p10k.zsh.
#     [[ -f $ZDOTDIR/.p10k.zsh ]] && . $ZDOTDIR/.p10k.zsh
#     # POWERLEVEL9K_DISABLE_CONFIGURATION_WIZARD=true
# }
# use_p10k

# eval "$(starship init zsh)"


# 放在 starship-init.zsh 前面
# . $ZDOTDIR/snippets/zsh-defer.plugin.zsh
# starship-init.zsh is generated by /etc/pacman.d/hooks/starship-init.hook
. $ZDOTDIR/snippets/starship-init.zsh
. $ZDOTDIR/snippets/history.zsh
. $ZDOTDIR/snippets/key-bindings.zsh

# Delay loading some scripts.
# See https://github.com/romkatv/zsh-defer

# 注意：emulate -L zsh 的 -L 会设置一些选项，包括 LOCAL_OPTIONS，使得在函数内修改的 option 在函数退出时全部重置

# zsh-defer -a _delay_load

# 以下是 zsh-defer 延迟加载的简化版
# 让 shell 打开 /dev/null 文件用来 reading，并将得到的文件描述符赋值给 fd 变量
exec {fd}</dev/null
# 当 /dev/null readable 时，就会调用 __delay_load handler
# /dev/null 总是 readable 的
zle -F $fd __delay_load
# unset fd 变量
unset fd

__delay_load() {
    # $1 的值就是之前的 fd 的值
    # 重新为 fd 安装 handler 取代之前的 handler，这里是空的，也就是说现在 fd 没有 handler
    zle -F $1
    # 关闭 $1 这个文件描述符
    exec {1}<&-
    # 可以 ls -la /proc/$$/fd/ 查看 zsh 当前打开了哪些文件

    # vscode 的 integrated shell 可能将 ZDOTDIR export 并修改为 /tmp/vscode-zsh，这里把它改回来
    unset ZDOTDIR; ZDOTDIR=$XDG_CONFIG_HOME/zsh
    # 执行我们要延迟执行的脚本
    . $ZDOTDIR/snippets/delay-load.zsh

    # 右侧的 prompt 为空
    RPROMPT=""
    # PROMPT2="$(/usr/bin/starship prompt --continuation)"

    # 卸载 zinit 模块
    # zmodload -u zdharma_continuum/zinit > /dev/null

    # 如果 $HOME/.zshrc 比 $HOME/.zshrc.zwc 新，就 zcompile 生成 $HOME/.zshrc
    [[ $(realpath $HOME/.zshrc) -nt $HOME/.zshrc.zwc ]] && zcompile $HOME/.zshrc
    unfunction __delay_load
    return 0
}

# TODO
# `z` 命令，不限于本次登陆或者最近去过的几级路径
# 自己写一个，优先展示本次会话的历史路径，再是其他的
# https://github.com/rupa/z
# https://github.com/agkozak/zsh-z 对 rupa/z 的移植和加强
# 再探索一下 fzf（如果能模糊搜索所有的历史 pwd 就好了）
# https://github.com/skywind3000/vim/blob/master/etc/zshrc.zsh
# https://github.com/romkatv/zsh4humans
# https://github.com/romkatv/zsh-bench#benchmark-results 可以看出 starship 的性能并不好（主要是因为fork+execve）
# 如果能够将 starship 作为 zsh 的一个 module 来调用？
# 很轻量，据说比 zinit 还快 https://github.com/jandamm/zgenom
# https://blog.quarticcat.com/posts/how-do-i-make-my-zsh-smooth-as-fuck/

# TODO 字体图标宽度问题
# print -lP -- '我x\UF303x'

# wget -O grml-zsh.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc

# 出于某种原因，我没让 journal 把日志写进 /var/log/journal
# journal 会把日志写到 /var/run/log/journal
[[ ! -d /var/log/journal ]] || echo "注意：/var/log/journal/ exists"
